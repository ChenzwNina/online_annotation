<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Widget Annotation</title>
    <style>
        hr.dashed {
        border-top: 2px dashed #bbb;
        }

        .clickable {
            text-decoration: none; /* Removes underline from the link */
            color: rgb(30, 108, 226); /* Sets text color */
        }

        .clickable:hover {
            color: #6aa7e8; /* Button hover effect */
        }

        /* Clear floats after the columns */
        .container {
            display: flex; /* Use Flexbox for layout */
            gap: 20px; /* Adds 20px space between columns */
            justify-content: center; /* Center the columns horizontally */
        }

        .column:first-child {
            flex: 0 0 60%; /* Left column takes 70% of the container */
            max-width: 60%; /* Prevent it from growing larger than 70% */
        }

        .column:last-child {
            flex: 0 0 40%; /* Right column takes 30% of the container */
            max-width: 40%; /* Prevent it from growing larger than 30% */
        }

        .column img {
            max-width: 100%;
            height: auto; /* Ensure the image scales properly */
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 4px; /* Rounded corners for buttons */
            background-color: #007bff; /* Button background color */
            color: white; /* Button text color */
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3; /* Button hover effect */
        }

        .inline-buttons {
            display: flex;
            justify-content: left;  
            gap: 10px; /* Add spacing between the buttons */
            margin-top: 20px; /* Add some spacing above the buttons */
        }

    </style>
</head>

<body>
    <div class="container">
        <div class="column">
            <div id="video-scenes">
                <!-- Video scenes will be dynamically inserted here -->
            </div>
        </div>
        <div class="column">
            <h2>Dark Pattern Category Selection</h2>
            <a href="https://docs.google.com/document/d/1N6PxylN0ZMmg9i23Z0Zsmfo3J6Kj6oztqCK-69QNhbI/edit?usp=sharing" class="clickable">
                View Rubric and Reference Paper
            </a>
            <p>Is this design a dark pattern?</p>
            <div>
                <hr class="dashed">
                <label for="not-dark-pattern">
                    <input type="radio" name="dark_pattern_type" id="not-dark-pattern" value ="not-dark-pattern">
                    Not a Dark Pattern
                </label>
                <label for="not-sure">
                    <input type="radio" name="dark_pattern_type" id="not-sure" value ="not-sure">
                    Need a discussion
                </label>
                <label for="cannot-see">
                    <input type="radio" name="dark_pattern_type" id="cannot-see" value ="cannot-see">
                    Can't see/issue loading widget
                </label>
                <hr class="dashed">
                <h4>
                    <label for="Asymmetric">
                        <input type="checkbox" name="dark_pattern_type" id="Asymmetric" value ="Asymmetric">
                        Asymmetric
                    </label>
                </h4>
                <p>Unequal burdens on choices available to the user.</p>
                <hr class="dashed">
                <h4>
                    <label for="Covert">
                        <input type="checkbox" name="dark_pattern_type" id="Covert" value ="Covert">
                        Covert
                    </label>
                </h4>
                <p>Hiding the influence mechanism from users.</p>
                <hr class="dashed">
                <h4>
                    <label for="Deceptive">
                        <input type="checkbox" name="dark_pattern_type" id="Deceptive" value ="Deceptive">
                        Deceptive
                    </label>
                </h4>
                <p>Induce false beliefs in users either through affirmative misstatements, misleading statements, or omissions.</p>
                <hr class="dashed">
                <h4>
                    <label for="Hides-Information">
                        <input type="checkbox" name="dark_pattern_type" id="Hides-Information" value ="Hides-Informations">
                        Hides Information
                    </label>
                </h4>
                <p>Obscure or delay the presentation of necessary information to users.</p>
                <hr class="dashed">
                <h4>
                    <label for="Restrictive">
                        <input type="checkbox" name="dark_pattern_type" id="Restrictive" value ="Restrictive">
                        Restrictive
                    </label>
                </h4>
                <p>Eliminate certain choices that should be available to users.</p>
                <hr class="dashed">
                <h4>
                    <label for="Disparate-Treatment ">
                        <input type="checkbox" name="dark_pattern_type" id="Disparate-Treatment " value ="Disparate-Treatment">
                        Disparate Treatment
                    </label>
                </h4>
                <p>Disadvantage and treat one group of users differently from another.</p>
                
            </div>

            <h2>Dark Pattern Impact</h2>
            <p> If a dark pattern exists, select its impact. If there is no dark pattern, skip this section. </p>
            <h4> 1. Which aspects of users' behavior or experience might be affected by the dark pattern? </h4>
            <thread> 
                <p>
                    <label for="financial-loss">
                        <input type="checkbox" name="dark_pattern_impact" id="financial-loss" value ="financial-loss">
                        Financial loss
                    </label>
                </p>
                <p>
                    <label for="Privacy">
                        <input type="checkbox" name="dark_pattern_impact" id="financial-loss" value ="privacy">
                        Privacy
                    </label>
                </p>
                <p>
                    <label for="Cognition">
                        <input type="checkbox" name="dark_pattern_impact" id="cognition" value ="cognition">
                        Cognitive burden, including time, energy, and attention.
                    </label>
                </p>
                <h4> 2. Rate the magnitude of the influence</h4>
                <tbody>
                    <label for="low-influence">
                        <input type="radio" name="magnitude" id="low-influence" value ="low-influence">
                        Low influence
                    </label>
                    <label for="moderate-influence">
                        <input type="radio" name="magnitude" id="slight-influence" value ="slight-influence">
                        Moderate influence
                    </label>
                    <label for="high-influence">
                        <input type="radio" name="magnitude" id="high-influence" value ="high-influence">
                       High influence
                    </label>
                </tbody>
            </thread> 
            <div class = "inline-buttons">
                <button id="prev-button">Previous</button>
                <button id="next-button">Next</button>
            </div>
        </div>
    </div>


    <script>
    
        // Select all checkboxes and radio buttons
        const allTypeCheckboxes = document.querySelectorAll('input[name="dark_pattern_type"][type="checkbox"]');
        const allTypeRadios = document.querySelectorAll('input[name="dark_pattern_type"][type="radio"]');

        // Function to uncheck radio buttons when a checkbox is selected
        function uncheckRadios() {
            allTypeRadios.forEach((radio) => {
                radio.checked = false; // Uncheck all radio buttons
            });
        }

        // Function to uncheck checkboxes when a radio button is selected
        function uncheckcheckBox() {
            allTypeCheckboxes.forEach((checkbox) => {
            checkbox.checked = false; // Uncheck all checkboxes
        });
        }

        // Add event listeners to all checkboxes
        allTypeCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", uncheckRadios);
        });

        // Add event listeners to all radio buttons
        allTypeRadios.forEach((radio) => {
        radio.addEventListener("change", uncheckcheckBox);
        });


        async function fetchVideoData() {
            const response = await fetch('widget_data.json');
                
            if (response) {
                console.log("Data JSON fetch succeeded")
                return await response.json();}
        }

        function getQueryParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            console.log(urlParams.get(name));
            return urlParams.get(name);
        }

        let videoSource = {};

        async function createVideoScene(videoPair) {
            const scene = document.createElement('div');

            scene.innerHTML = `
            <div>
                <h2><Widget Image</h2>
                <img alt="design_screenshot sizes="print 73px,117px" src="${videoPair.screenshot_location}">
            </div>
            `;

            const response = await fetch('https://rate.chenziwei0499.workers.dev/get', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    key: getQueryParameter('videoIndex')
                })
            });

            const data_text = await response.text();
            if (!data_text || data_text.trim() === "") {
                console.log("Empty response body.");
                return scene;
            }

            const data = JSON.parse(JSON.parse(data_text));
            console.log("Raw Response Body:", data);
                
            // Pre-populate selected dark pattern type
            const type = data.value.dark_pattern_type; // Type is an array or a single string
            if (!type) { // Check if type is null, undefined, or false
                    console.warn("dark_pattern_type is undefined or null.");
            } else {
                if (type === 'not-dark-pattern') {
                    // Check not dark pattern radio boxs
                    document.querySelector('#not-dark-pattern').checked = true;

                    // Uncheck all checkboxes
                    document.querySelectorAll('input[type="checkbox"][name="dark_pattern_type"]').forEach((checkbox) => {
                        checkbox.checked = false;
                    });
                }else if (type === 'not-sure-sure') {
                    // Check not dark pattern radio box
                    document.querySelector('#not-sure').checked = true;

                    // Uncheck all checkboxes
                    document.querySelectorAll('input[type="checkbox"][name="dark_pattern_type"]').forEach((checkbox) => {
                        checkbox.checked = false;
                    });
                } else {
                    console.log("Checked answers for dark pattern types are", type);

                    if (typeof type === "string") {
                        type = [type]; // Convert string to an array
                    }

                    if (Array.isArray(type)) { // Ensure type is an array before using forEach
                        type.forEach((dark_type) => {
                            const checkbox = document.querySelector(`input[name="dark_pattern_type"][value="${dark_type}"]`);
                            if (checkbox) {
                                checkbox.checked = true;
                            } else {
                                console.warn(`Checkbox for value "${dark_type}" not found.`);
                            }
                        });
                    } else {
                        console.error("Unexpected type format:", type);
                    }
                }
            }
            
            // Pre-populate already selected dark pattern impact
            const impact_value = data.value.dark_pattern_impact // Type is an array or a single string
            console.log("dark_pattern_impact" + impact_value)
            if (!impact_value) { // Check if type is null, undefined, or false
                console.warn("dark_pattern_impact is undefined or null.");
            } else {
                console.log("Checked answers for dark pattern types are", type);
                if (typeof impact_value === "string") {
                    impact_value = [impact_value]; // Convert string to an array
                }

                if (Array.isArray(impact_value)) { // Ensure impact is an array before using forEach
                    impact_value.forEach((dark_impact) => {
                        const checkbox = document.querySelector(`input[name="dark_pattern_impact"][value="${dark_impact}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                        } else {
                            console.warn(`Checkbox for value "${dark_impact}" not found.`);
                        }
                    });
                } else {
                    console.error("Unexpected type format:", impact_value);
                }
            }

            const magnitude_value = data.value.dark_pattern_magnitude; // Severity is a string
            if (!magnitude_value) { // Check if type is null, undefined, or falsy
                    console.warn("Second statement is undefined or null.");
            } else {
                console.log("Checked answer for second statement is", magnitude_value);
                const magnitudeRadio = document.querySelector(`input[name="magnitude"][value="${magnitude_value}"]`); //Get data
                magnitudeRadio.checked = true; // Set the radio button as checked
            }

            return scene;
            }


        async function showScene() {
            const videoData = await fetchVideoData();
            console.log("Video Data :" + JSON.stringify(videoData));
            const videoIndex = getQueryParameter('videoIndex');
            const videoScenes = document.getElementById('video-scenes');
            videoScenes.innerHTML = '<p> Current widget index: ' + videoIndex;

            if (videoIndex !== null && videoIndex < videoData.length && videoIndex >= 0) {
                console.log("Video Data[index]: "+ JSON.stringify(videoData[videoIndex]));
                const scene = await createVideoScene(videoData[videoIndex]);
                videoSource = videoData[videoIndex];
                videoScenes.appendChild(scene);
            } else {
                videoScenes.innerHTML = `
                    <p><strong>Invalid image index</strong></p>
                    <p> Current video index is ${videoIndex}. Total index is ${videoData.length}.</p>
                `;
            }


        }

        // Initialize by showing the scene based on the URL parameter
        showScene();

        function collectData() {
            const urlParams = new URLSearchParams(window.location.search);
            const videoIndex = urlParams.get('videoIndex');
            const dark_pattern_type = document.querySelectorAll('input[name="dark_pattern_type"]:checked');
            const dark_pattern_impact = document.querySelectorAll('input[name="dark_pattern_impact"]:checked');
            const dark_pattern_magnitude = document.querySelector('input[name="magnitude"]:checked');

            // Get the value of dark_pattern_type
            const darkPatternType = dark_pattern_type.length > 0
                ? Array.from(dark_pattern_type).map(checkbox => checkbox.value)
                : null;

            const darkPatternImpact = dark_pattern_impact.length > 0
                ? Array.from(dark_pattern_impact).map(checkbox => checkbox.value)
                : null;

            const data = {
                dark_pattern_type: darkPatternType,
                dark_pattern_impact: darkPatternImpact,
                dark_pattern_magnitude: dark_pattern_magnitude ?dark_pattern_magnitude.value : null,
            };

            return data;
        }

        async function uploadData() {
            const data = collectData();
            Toast('Uploading data...', 1000);
            let myuuid = crypto.randomUUID();
            const response = await fetch('https://rate.chenziwei0499.workers.dev/upload', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    key: myuuid,
                    index: getQueryParameter('videoIndex'),
                    rater: getQueryParameter('user')
                })
            });
            // Toast(JSON.stringify(await response.json()), 1000);
            console.log(JSON.stringify({
                    key: getQueryParameter('videoIndex'),
                    value: data
                }));
            const response1 = await fetch('https://rate.chenziwei0499.workers.dev/put', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    key: getQueryParameter('videoIndex'),
                    rater: getQueryParameter('user'),
                    value: data
                })
            });
            await Toast(JSON.stringify(await response1.json()), 1000);
        }

        async function goToNextScene() {
            const videoIndex = parseInt(getQueryParameter('videoIndex'), 10);
            await uploadData();
            const nextIndex = isNaN(videoIndex) ? 0 : videoIndex + 1;
            console.log("Next Scene Index is :"+ nextIndex)
            window.location.search = `?videoIndex=${nextIndex}&user=${getQueryParameter('user')}`;

        }

        async function goToPrevScene() {
            const videoIndex = parseInt(getQueryParameter('videoIndex'), 10);
            await uploadData();
            const nextIndex = isNaN(videoIndex) ? 0 : videoIndex - 1;
            window.location.search = `?videoIndex=${nextIndex}&user=${getQueryParameter('user')}`;
        }

        async function Toast(msg, duration) {
            duration = isNaN(duration) ? 3000 : duration;
            var m = document.createElement('div');
            m.textContent = msg;
            m.style.cssText = "max-width:60%;min-width: 150px;padding:0 14px;height: 40px;color: rgb(255, 255, 255);line-height: 40px;text-align: center;border-radius: 4px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);z-index: 999999;background: rgba(0, 0, 0,.7);font-size: 16px;";
            document.body.appendChild(m);
            setTimeout(function () {
                var d = 0.5;
                m.style.webkitTransition = '-webkit-transform ' + d + 's ease-in, opacity ' + d + 's ease-in';
                m.style.opacity = '0';
                setTimeout(function () { document.body.removeChild(m) }, d * 1000);
            }, duration);
            // wait for the toast to disappear
            await new Promise(r => setTimeout(r, duration));
        }


        document.getElementById('next-button').addEventListener('click', goToNextScene);
        document.getElementById('prev-button').addEventListener('click', goToPrevScene);
    </script>
</body>

</html>